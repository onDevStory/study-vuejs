https://kr.vuejs.org/v2/guide/instance.html#속성과-메소드
  ? 각 Vue 인스턴스는 data 객체에 있는 모든 속성을 프록시 처리 합니다.

  ? 이러한 프록시 속성은 반응형 입니다.
    인스턴스를 작성한 후 인스턴스에 새 특성을 첨부하면 뷰 업데이트가 트리거되지 않습니다.

  ? $watch
    script 상에서의 빠른 변화에서는 1번만 호출이 됨. why?

https://kr.vuejs.org/v2/guide/instance.html#라이프사이클-다이어그램

https://kr.vuejs.org/v2/guide/syntax.html#수식어
  수식어는 점으로 표시되는 특수 접미사로, 디렉티브를 특별한 방법으로 바인딩 해야 함을 나타냅니다.
  예를 들어, .prevent 수식어는 트리거된 이벤트에서 event.preventDefault()를 호출하도록
  v-on을 디렉티브에 알려줍니다.
    <form v-on:submit.prevent="onSubmit"></form>

Shorthands (약어)
  가장 자주 사용되는 두개의 디렉티브인 v-bind와 v-on에 대해 특별한 약어를 제공합니다.
    <a v-on:click="doSomething"></a>    =>         <a @click="doSomething"></a>
    <a v-bind:href="url"></a>           =>         <a :href="url"></a>

https://kr.vuejs.org/v2/guide/computed.html#기본-예제
  Computed Properties and Watchers
    In-template expressions are very convenient, 하지만 단순한 연산에만 사용해야 합니다.
    For any complex logic, you should use a computed property.
    (computed 에 선언한 function 은 console 에서 vm._computedWatchers 로 찾을 수 있음)
    
    Here we have declared a computed property reversedMessage.
    The function we provided will be used as the getter function for the property vm.reversedMessage:
    You can open the console and play with the example vm yourself.
    The value of vm.reversedMessage is always dependent on the value of vm.message.
      console.log(vm.reversedMessage) // -> 'olleH'
      vm.message = 'Goodbye'
      console.log(vm.reversedMessage) // -> 'eybdooG'
    
    그러면 data 에 reversedMessage 란 속성을 선언하면 안되는거네..
    속성이나 함수를 선언할 때 항상 신경써야만 되는건가..?

  주의사항
    If the function which has a same name exist in methods option...??
      O : <p>Using computed properties: "{{ reversedMessage }}"</p> 
      X : <p>Using computed properties: "{{ reversedMessage() }}"</p>
          

      그렇다면 In-template expressions 에서 methods 사용 시에는,
      무조건 ()를 명시적으로 붙이고(필수), computed 는 안붙이면 되는거군!
      그리고 reversedMessage 가 vm.reversedMessage 의 getter function 으로 사용된다는 건,
      뭔가 logic 을 타야 되는 속성이 있을 땐 data 가 아닌 computed 에 선언하면 되는거구나!

  Questions
    methods 에 선언해 사용하는 것과 computed 에 선언해 사용하는 것 중, 선택기준은?

https://kr.vuejs.org/v2/guide/computed.html#계산된-캐싱-vs-메소드
  computed properties are cached based on their dependencies.
  A computed property will only re-evaluate when some of its dependencies have changed.
    var vm = new Vue({
		  el: '#demo',
		  data: {
		    firstName: 'Foo',
		    lastName: 'Bar'
		  },
		  computed: {
		    fullName: function () {
		      return this.firstName + ' ' + this.lastName
		    }
		  }
		})
    
    fullName 은 firstName & lastName 에 종속되어 있어서,
    의존하는 속성 값이 변경할 때마다 fullName 도 다시 계산된다.

  In comparison, a method invocation will always run the function whenever a re-render happens.

  In cases where you do not want caching, use a method instead.

https://kr.vuejs.org/v2/guide/computed.html#계산된-속성-vs-감시된-속성
  fullName 이 firstName & lastName 값의 변화에 따라 변경되야 한다면,
  firstName & lastName 을 watch 하는 것보다는 fullName 을 computed 하는 것을 선택할 것!

https://kr.vuejs.org/v2/guide/computed.html#계산된-Setter !!

https://kr.vuejs.org/v2/guide/computed.html#감시자 !!

https://kr.vuejs.org/v2/guide/class-and-style.html#HTML-클래스-바인딩하기
  https://kr.vuejs.org/v2/guide/class-and-style.html#컴포넌트와-함께-사용하는-방법

https://kr.vuejs.org/v2/guide/class-and-style.html#배열-구문-1
  https://kr.vuejs.org/v2/guide/class-and-style.html#자동-접두사

https://vuejs.org/v2/guide/conditional.html#v-if-vs-v-show
  Generally speaking, v-if has higher toggle costs while v-show has higher initial render costs.
  So prefer v-show if you need to toggle something very often,
  and prefer v-if if the condition is unlikely to change at runtime.

https://vuejs.org/v2/guide/conditional.html#v-if-with-v-for
  When used together with v-for, v-for has a higher priority than v-if.

https://kr.vuejs.org/v2/guide/list.html#컴포넌트와-v-for

https://kr.vuejs.org/v2/guide/list.html#v-for와-v-if

https://kr.vuejs.org/v2/guide/list.html#key

Array Chane Detection
  https://kr.vuejs.org/v2/guide/list.html#변이-메소드
    push(), pop(), shift(), unshift(), splice(), sort(), reverse()
    ex) vm.items.push({ message: 'Baz' })

  https://kr.vuejs.org/v2/guide/list.html#배열-대체
    filter(), concat(), slice()
    ex) example1.items = example1.items.filter(function (item) {
          return item.message.match(/Foo/)
        })
  https://kr.vuejs.org/v2/guide/list.html#주의-사항

https://kr.vuejs.org/v2/guide/list.html#필터링-정렬-된-결과-표시하기

https://kr.vuejs.org/v2/guide/events.html#이벤트-수식어
  .stop  .prevent  .capture  .self  .once

https://kr.vuejs.org/v2/guide/events.html#키-수식어
  .enter  .tab  .esc  .space  .up  .down  .left  .right
  .delete (“Delete” 와 “Backspace” 키 모두를 캡처합니다)
  
  <!-- keyCode가 13일 때만 vm.submit()을 호출합니다 -->
  <input v-on:keyup.13="submit">

  <!-- 위와 같습니다 -->
	<input v-on:keyup.enter="submit">

	<!-- 약어 사용도 가능합니다 -->
	<input @keyup.enter="submit">

  You can also define custom key modifier aliases via the global config.keyCodes object:
    // enable v-on:keyup.f1
    Vue.config.keyCodes.f1 = 112

https://kr.vuejs.org/v2/guide/events.html#수식어-키-목록
  .ctrl  .alt  .shift  .meta (windows)

  <!-- Alt + C -->
	<input @keyup.alt.67="clear">

	<!-- Ctrl + Click -->
	<div @click.ctrl="doSomething">Do something</div>

https://kr.vuejs.org/v2/guide/events.html#마우스-버튼-수식어
  .left  .right  .middle

Form Input Bindings (Basic Usage)
  v-model will ignore the initial value, checked or selected attributes found on any form elements.
  It will always treat the Vue instance data as the source of truth.
  You should declare the initial value on the JavaScript side, inside the data option of your component.

컴포넌트
  Using Components
    Registration
    Local Registration
      동일한 캡슐화는 디렉티브와 같은 다른 등록 가능한 Vue 기능에도 적용됩니다. ??
    DOM Template Parsing Caveats
      이해 안됨.

https://kr.vuejs.org/v2/guide/components.html#data-는-반드시-함수여야합니다
  컴포넌트 인스턴스가 같은 데이터를 공유하게 할 수도 안할 수도 있음. 소스참조.

https://kr.vuejs.org/v2/guide/components.html#컴포넌트-작성
  props down, events up.
  The parent passes data down to the child via props,
  and the child sends messages to the parent via events.

https://kr.vuejs.org/v2/guide/components.html#Props로-데이터-전달하기
  데이터와 마찬가지로 prop은 템플릿 내부에서 사용할 수 있으며
  vm의 this.message로 사용할 수 있습니다. ?? 예제가 필요해...OK

https://kr.vuejs.org/v2/guide/components.html#camelCase-vs-kebab-case
  HTML attributes are case-insensitive, so when using non-string templates,
  camelCased prop names need to use their kebab-case (hyphen-delimited).

https://kr.vuejs.org/v2/guide/components.html#리터럴-vs-동적
  어차피 화면에 뿌려지는 거면 string 이든 number 든 똑같을텐데,
  component 안에서 myMessage 란 변수를 직접 사용하는 예제가 있었다면!

  https://kr.vuejs.org/v2/guide/components.html#단방향-데이터-흐름

