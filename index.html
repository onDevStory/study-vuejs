<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <title>Vue JS Guide</title>
    <script type="text/javascript" src="https://unpkg.com/vue"></script>
</head>

<body>
    <div id="example">
        <h2>Template Syntax</h2>
        <details>
            <summary :id="'h2-' + id.title">Template Syntax</summary>
            <p v-once>one-time interpolations (This will never change): {{ msg }}</p>
            <div v-html="html.aa"></div>
            <button v-bind:disabled="buttonFlag">Button</button>
            <!-- v-bind 에서 method 사용 시에는 () 생략 가능하네 -->
            <button :disabled="getBoolean">Button</button>
            <button :disabled="!getBoolean()">Button</button>
            <p>{{true? true:false | capitalize | append('★')}}</p>
            <p>{{Math.random()}}</p>
            modify the value of buttonFlag
            <button v-if="buttonFlag">보인다</button>
            <p>Original message: "{{ msg }}"</p>
            <p>Using In-template expressions: {{msg.split('').reverse().join('')}}</p>
            <p>Using computed properties: "{{ reversedMessage }}"</p>
        </details>

        <hr>
        <h2>Binding HTML Classes</h2>
        <details>
            <summary>Binding HTML Classes</summary>

            <div :class="{ active: isActive }">
                :class="{ active: isActive }"
            </div>
            <div class="static" :class="{ active: isActive, 'text-danger': hasError }">
                :class="{ active: isActive, 'text-danger': hasError }"
            </div>
            <hr>
            <div :class="classObject">
                The bound object doesn’t have to be inline: This will render the same result.
            </div>
            <hr>
            <div :class="computedClass">
                We can also bind to a computed property that returns an object.
                <br> This is a common and powerful pattern: ★ Not Working...
            </div>
            <hr>
            <div :class="[classArray.activeClass, classArray.errorClass]">
                BASIC - :class="[classArray.activeClass, classArray.errorClass]"
            </div>
            <hr>
            <div class="static" :class="[classArray.errorClass, isActive? classArray.activeClass:'']">
                BAD - :class="static" :class="[classArray.errorClass, isActive? classArray.activeClass:'']"
            </div>
            <hr>
            <div class="static" :class="[classArray.errorClass, {active: isActive}]">
                GOOD - :class="static" :class="[classArray.errorClass, {active: isActive}]"
                <br> It is possible to use the object syntax inside array syntax
            </div>
        </details>

        <hr>
        <h2>Binding Inline Styles</h2>
        <details>
            <summary>Binding Inline Styles</summary>
            <div>
                You can use either camelCase or kebab-case (use quotes with kebab-case) for the CSS property names:
                <br>
                <span :style="{ color: activeColor, fontSize: fontSize + 'px' }">
                    :style="{ color: activeColor, fontSize: fontSize + 'px' }"
                </span>
            </div>
            <hr>
            <div>
                It is often a good idea to bind to a style object directly so that the template is cleaner:
                <br>
                <span :style="styleObject">
                    :style="styleObject"
                </span>
            </div>
            <hr>
            <div>
                Again, the object syntax is often used in conjunction with computed properties that return objects.
                <br>
                <span :style="computedStyle">
                    :style="computedStyle"
                </span>
            </div>
        </details>

        <hr>
        <h2>Conditional Rendering</h2>
        <details>
            <summary>v-if</summary>
            <div>
                A v-else element must immediately follow a v-if or a v-else-if element
                <br>- otherwise it will not be recognized.
                <div v-if="ok">Yes</div>
                <div v-else>No</div>
            </div>
            <hr>
            <div>
                we can use v-if on a &lt template&gt element, which serves as an invisible wrapper.
                <br>The final rendered result will not include the &lttemplate&gt element.
                <br>
                <template>
                    Check it source-code out for yourself for this and below.
                    <br> template tag is not exist.
                </template>
                <template v-if="ok">
                    <div>Title</div>
                    <span>Paragraph 1</span>
                    <br>
                    <span>Paragraph 2</span>
                </template>
            </div>
            <hr>
            <div>
                <div v-if="type === 'A'">
                    A
                </div>
                <div v-else-if="type === 'B'">
                    B
                </div>
                <div v-else-if="type === 'C'">
                    C
                </div>
                <div v-else>
                    Not A/B/C
                </div>
            </div>
            <hr>
            <div>
                Switching the loginType in the code above will not erase
                <br> what the user has already entered.
                <br> Since both templates use the same elements, the &ltinput&gt is not replaced - just its placeholder.
                <br>
                <template v-if="loginType === 'username'">
                    <label>Username</label>
                    <input placeholder="Enter your username">
                </template>
                <template v-else>
                    <label>Email</label>
                    <input placeholder="Enter your email address">
                </template>
                <br>
                <br> To don't re-use them, Just add a key attribute with unique values.
                <br> Note that the &ltlabel&gt elements are still efficiently re-used,
                <br>because they don’t have key attributes.
                <br>
                <template v-if="loginType === 'username'">
                    <label>Username</label>
                    <input placeholder="Enter your username" key="username-input">
                </template>
                <template v-else>
                    <label>Email</label>
                    <input placeholder="Enter your email address" key="email-input">
                </template>
                <br>
                <button v-on:click="loginType=='username'? loginType='email':loginType='username'">
                    Toggle loginType
                </button>
            </div>
        </details>
        <details>
            <summary>v-show</summary>
            The difference is that an element with v-show will always be rendered and remain in the DOM;
            <br>v-show simply toggles the display CSS property of the element.
            <br>Note that v-show doesn’t support the &lttemplate&gt syntax, nor does it work with v-else.
            <div v-show="ok">Hello!</div>
        </details>
        <hr>
        <h2>List Rendering</h2>
        <details>
            <summary>Basic Usage</summary>
            <ul>
                <li v-for="item in items">
                    {{ item.message}}
                </li>
            </ul>
            <hr>
            <ul id="example-2">
                <li v-for="(item, index) in items">
                    {{ parentMessage }} - {{ index }} - {{ item.message }}
                </li>
            </ul>
            <hr>
            <div v-for="item of items">
                {{ item.message }}
            </div>
        </details>
        <details>
            <summary>Template v-for</summary>
            <ul>
                <template v-for="item in items">
                    <li>{{ item.message }}</li>
                    <li class="divider">v-for</li>
                </template>
            </ul>
        </details>
        <details>
            <summary>Object v-for</summary>
            When iterating over an object, the order is based on the key enumeration order of Object.keys(), => Object.keys(vm.object)
            <br> which is not guaranteed to be consistent across JavaScript engine implementations.
            <ul class="demo">
                <li v-for="value in object">
                    {{ value }}
                </li>
            </ul>
            <hr>
            <div v-for="(value, key) in object">
                {{ key }} : {{ value }}
            </div>
            <hr>
            <div v-for="(value, key, index) in object">
                {{ index }}. {{ key }} : {{ value }}
            </div>
        </details>
        <details>
            <summary>Range v-for</summary>
            <div>
                <span v-for="n in 10">{{ n }} </span>
            </div>
        </details>
        <details>
            <summary>Displaying Filtered/Sorted Results</summary>
            <div>
                <li v-for="n in evenNumbers">{{ n }}</li>
            </div>
            <hr>
            <div>
                <li v-for="n in even(numbers)">{{ n }}</li>
            </div>
        </details>
        <hr>
        <h2>Event Handling</h2>
        <details>
            <summary>Listening to Events</summary>
            <button v-on:click="counter += 1">Add 1</button>
            <br>
            <p>위 버튼을 클릭한 횟수는 {{ counter }} 번 입니다.</p>
        </details>
        <details>
            <summary>Method Event Handler</summary>
            <button v-on:click="greet">Greet</button>
        </details>
        <details>
            <summary>Methods in Inline Handlers</summary>
            <button v-on:click="say('hi')">Say hi</button>
            <button v-on:click="say('what')">Say what</button>
            <br>
            <button v-on:click="warn('Form cannot be submitted yet.', $event)">Submit</button>
        </details>
        <hr>
        <h2>Form Input Bindings</h2>
        <details>
            <summary>Text</summary>
            For languages that require an IME (Chinese, Japanese, Korean etc.),
            <br>you’ll notice that v-model doesn’t get updated during IME composition.
            <br>If you want to cater for these updates as well, use input event instead.
            <br>한글 입력 시 늦는 현상 말하는건가?
            <br>
            <input v-model="message" placeholder="여기를 수정해보세요"> 메시지: {{ message }}
        </details>
        <details>
            <summary>Multiline Text</summary>
            <span>여러 줄을 가지는 메시지:</span>
            <p style="white-space: pre">{{ longMessage }}</p>
            <textarea v-model="longMessage" placeholder="여러줄을 입력해보세요"></textarea>
        </details>
        <details>
            <summary>Checkbox</summary>
            <input type="checkbox" id="checkbox" v-model="checked">
            <label for="checkbox">{{ checked }}</label>
            <hr>
            <input type="checkbox" id="jack" value="Jack" v-model="checkedNames">
            <label for="jack">Jack</label>
            <input type="checkbox" id="john" value="John" v-model="checkedNames">
            <label for="john">John</label>
            <input type="checkbox" id="mike" value="Mike" v-model="checkedNames">
            <label for="mike">Mike</label>
            <br>
            <span>체크한 이름: {{ checkedNames }}</span>
        </details>
        <details>
            <summary>Radio</summary>
            <input type="radio" id="one" value="1" v-model="picked">
            <label for="one">One</label>
            <br>
            <input type="radio" id="two" value="2" v-model="picked">
            <label for="two">Two</label>
            <br>
            <span>선택: {{ picked }}</span>
        </details>
        <details>
            <summary>Select</summary>
            <select v-model="selected">
                <option disabled value="">Please select one</option>
                <option>A</option>
                <option>B</option>
                <option>C</option>
            </select>
            <span>선택함: {{ selected }}</span>
            <hr>
            <select v-model="multiSelected" multiple>
                <option value="a">A</option>
                <option value="b">B</option>
                <option value="c">C</option>
            </select>
            <br>
            <span>multiSelected: {{ multiSelected }}</span>
            <hr>
            <select v-model="selected2">
                <option v-for="option in options" v-bind:value="option.value">
                    {{ option.text }}
                </option>
            </select>
            <span>Selected: {{ selected2 }}</span>
        </details>
        <details>
            <summary>Value Bindings - 잘 이해안됨</summary>
            처음에는 그냥 true or false 로 되네.
            <br>
            <input type="checkbox" v-model="toggle" v-bind:true-value="a" v-bind:false-value="b"> {{ toggle }}
            <hr>
            <input type="radio" v-model="pick" v-bind:value="a"> {{ pick }}
            <hr>
            <select v-model="selected3">
                <option disabled value="">Please select one</option>
                <option v-bind:value="{ number: 123 }">123</option>
            </select>
            {{ selected3 }}
        </details>
        <details>
            <summary>Modifiers</summary>
            v-model.lazy: synced after "change" instead of "input"
            <br>
            <input v-model.lazy="msg"> {{ msg }}
            <hr>
            <input v-model.number="age" type="number"> {{ age }}
            <hr>
            <input v-model.trim="msg"> {{ msg }}
        </details>
    </div>
    <br>
    <br>
    <br>
    <br>
    <!-- where the rear which dom rendering is completed -->
    <script type="text/javascript " src="app01.js "></script>
</body>

</html>
