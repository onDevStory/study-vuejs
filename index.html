<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <title>Vue JS Guide</title>
    <script type="text/javascript" src="https://unpkg.com/vue"></script>
</head>

<body>
    <div id="example">
        <h2>Template Syntax</h2>
        <details>
            <summary :id="'h2-' + id.title">Template Syntax</summary>
            <p v-once>one-time interpolations (This will never change): {{ msg }}</p>
            <div v-html="html.aa"></div>
            <button v-bind:disabled="buttonFlag">Button</button>
            <!-- v-bind 에서 method 사용 시에는 () 생략 가능하네 -->
            <button :disabled="getBoolean">Button</button>
            <button :disabled="!getBoolean()">Button</button>
            <p>{{true? true:false | capitalize | append('★')}}</p>
            <p>{{Math.random()}}</p>
            modify the value of buttonFlag
            <button v-if="buttonFlag">보인다</button>
            <p>Original message: "{{ msg }}"</p>
            <p>Using In-template expressions: {{msg.split('').reverse().join('')}}</p>
            <p>Using computed properties: "{{ reversedMessage }}"</p>
        </details>

        <hr>
        <h2>Binding HTML Classes</h2>
        <details>
            <summary>Binding HTML Classes</summary>

            <div :class="{ active: isActive }">
                :class="{ active: isActive }"
            </div>
            <div class="static" :class="{ active: isActive, 'text-danger': hasError }">
                :class="{ active: isActive, 'text-danger': hasError }"
            </div>
            <hr>
            <div :class="classObject">
                The bound object doesn’t have to be inline: This will render the same result.
            </div>
            <hr>
            <div :class="computedClass">
                We can also bind to a computed property that returns an object.
                <br> This is a common and powerful pattern: ★ Not Working...
            </div>
            <hr>
            <div :class="[classArray.activeClass, classArray.errorClass]">
                BASIC - :class="[classArray.activeClass, classArray.errorClass]"
            </div>
            <hr>
            <div class="static" :class="[classArray.errorClass, isActive? classArray.activeClass:'']">
                BAD - :class="static" :class="[classArray.errorClass, isActive? classArray.activeClass:'']"
            </div>
            <hr>
            <div class="static" :class="[classArray.errorClass, {active: isActive}]">
                GOOD - :class="static" :class="[classArray.errorClass, {active: isActive}]"
                <br> It is possible to use the object syntax inside array syntax
            </div>
        </details>

        <hr>
        <h2>Binding Inline Styles</h2>
        <details>
            <summary>Binding Inline Styles</summary>
            <div>
                You can use either camelCase or kebab-case (use quotes with kebab-case) for the CSS property names:
                <br>
                <span :style="{ color: activeColor, fontSize: fontSize + 'px' }">
                    :style="{ color: activeColor, fontSize: fontSize + 'px' }"
                </span>
            </div>
            <hr>
            <div>
                It is often a good idea to bind to a style object directly so that the template is cleaner:
                <br>
                <span :style="styleObject">
                    :style="styleObject"
                </span>
            </div>
            <hr>
            <div>
                Again, the object syntax is often used in conjunction with computed properties that return objects.
                <br>
                <span :style="computedStyle">
                    :style="computedStyle"
                </span>
            </div>
        </details>

        <hr>
        <h2>Conditional Rendering</h2>
        <details>
            <summary>v-if</summary>
            <div>
                A v-else element must immediately follow a v-if or a v-else-if element
                <br>- otherwise it will not be recognized.
                <div v-if="ok">Yes</div>
                <div v-else>No</div>
            </div>
            <hr>
            <div>
                we can use v-if on a &lt template&gt element, which serves as an invisible wrapper.
                <br>The final rendered result will not include the &lttemplate&gt element.
                <br>
                <template>
                    Check it source-code out for yourself for this and below.
                    <br> template tag is not exist.
                </template>
                <template v-if="ok">
                    <div>Title</div>
                    <span>Paragraph 1</span>
                    <br>
                    <span>Paragraph 2</span>
                </template>
            </div>
            <hr>
            <div>
                <div v-if="type === 'A'">
                    A
                </div>
                <div v-else-if="type === 'B'">
                    B
                </div>
                <div v-else-if="type === 'C'">
                    C
                </div>
                <div v-else>
                    Not A/B/C
                </div>
            </div>
            <hr>
            <div>
                Switching the loginType in the code above will not erase
                <br> what the user has already entered.
                <br> Since both templates use the same elements, the &ltinput&gt is not replaced - just its placeholder.
                <br>
                <template v-if="loginType === 'username'">
                    <label>Username</label>
                    <input placeholder="Enter your username">
                </template>
                <template v-else>
                    <label>Email</label>
                    <input placeholder="Enter your email address">
                </template>
                <br>
                <br> To don't re-use them, Just add a key attribute with unique values.
                <br> Note that the &ltlabel&gt elements are still efficiently re-used,
                <br>because they don’t have key attributes.
                <br>
                <template v-if="loginType === 'username'">
                    <label>Username</label>
                    <input placeholder="Enter your username" key="username-input">
                </template>
                <template v-else>
                    <label>Email</label>
                    <input placeholder="Enter your email address" key="email-input">
                </template>
                <br>
                <button v-on:click="loginType=='username'? loginType='email':loginType='username'">
                    Toggle loginType
                </button>
            </div>
        </details>
        <details>
            <summary>v-show</summary>
            The difference is that an element with v-show will always be rendered and remain in the DOM;
            <br>v-show simply toggles the display CSS property of the element.
            <br>Note that v-show doesn’t support the &lttemplate&gt syntax, nor does it work with v-else.
            <div v-show="ok">Hello!</div>
        </details>
        <hr>
        <h2>List Rendering</h2>
        <details>
            <summary>Basic Usage</summary>
            <ul>
                <li v-for="item in items">
                    {{ item.message}}
                </li>
            </ul>
            <hr>
            <ul id="example-2">
                <li v-for="(item, index) in items">
                    {{ parentMessage }} - {{ index }} - {{ item.message }}
                </li>
            </ul>
            <hr>
            <div v-for="item of items">
                {{ item.message }}
            </div>
        </details>
        <details>
            <summary>Template v-for</summary>
            <ul>
                <template v-for="item in items">
                    <li>{{ item.message }}</li>
                    <li class="divider">v-for</li>
                </template>
            </ul>
        </details>
        <details>
            <summary>Object v-for</summary>
            When iterating over an object, the order is based on the key enumeration order of Object.keys(), => Object.keys(vm.object)
            <br> which is not guaranteed to be consistent across JavaScript engine implementations.
            <ul class="demo">
                <li v-for="value in object">
                    {{ value }}
                </li>
            </ul>
            <hr>
            <div v-for="(value, key) in object">
                {{ key }} : {{ value }}
            </div>
            <hr>
            <div v-for="(value, key, index) in object">
                {{ index }}. {{ key }} : {{ value }}
            </div>
        </details>
        <details>
            <summary>Range v-for</summary>
            <div>
                <span v-for="n in 10">{{ n }} </span>
            </div>
        </details>
    </div>

    <!-- where the rear which dom rendering is completed -->
    <script type="text/javascript " src="app01.js "></script>
</body>

</html>
